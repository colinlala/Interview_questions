## http、https
### http 
- 特点：
    1. **无连接**：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
    2. **无状态**：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销
    3. **灵活**：通过http协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
    4. **简单快速**：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单
- 缺点：
    1. **无状态**：请求不会记录任何连接信息，无法区分多个请求发起者身份是不是同一个客户端的，必须重传，每次连接传送的数据量增大
    2. **不安全**：明文传输可能被窃听不安全
    3. **明文传输**：报文(header部分)使用的是明文，直接将信息暴露给了外界
    4. **队头阻塞**：开启长连接时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态

### http报文 
    - 请求报文
        1. 请求行，Method、**uri**、http协议及版本
        2. 请求头：k ：v
        3. 空行
        4. 请求体：请求的参数
    - 响应报文
        1. 状态行，http协议及版本、状态码、原因
        2. 响应头：k ：v
        3. 空行
        4. 响应体：服务端返回的数据

### http请求方法
    - GET 获取资源
    - POST 提交数据，即上传数据
    - HEAD 获得报文首部
    - PUT 更新资源
    - PATCH 对PUT的补充，对**已知资源部分更新**
    - DELETE 删除资源
    - OPTIONS 列出请求资源支持的请求方法，用来跨域请求
    - TRACE 追踪请求/响应路径，用于测试或诊断
    - CONNECT 将连接改为管道方式用于代理服务器

### http状态码

|状态码|类别|描述|
|---|---|---|
|1xx|Informational（信息状态码）|目前是协议处理的中间状态，还需要后续操作|
|2xx|Success（成功状态码）|请求已被成功接收|
|3xx|Redirection（重定向状态码）|要完成请求必须进行进一步操作|
|4xx|Client Error（客户端错误状态码）|请求有语法错误或请求无法实现|
|5xx|Server Error（服务器错误状态码）|服务器未能实现合法的请求|

- 1xx
    - **101 Switching Protocols**，切换协议，服务器同意变更，发送101
- 2xx
    - **200 OK**，请求成功，通常在响应体中放有数据。
    - **204 No Content**，含义与 200 相同，但响应头后没有 body 数据。
    - **206 Partial Content**，表示部分内容，已完成指定范围的请求，它的使用场景为 HTTP 分块下载和断点续传，带上相应的响应头字段Content-Range。
- 3xx
    - **301 Moved Permanently**，永久重定向，网站升为https，以前的不用了，返回301，浏览器默认会做缓存优化，后续直接访问重定向的地址。
    - **302 Found**，临时重定向，浏览器不会做缓存优化
    - **304 Not Modified**，所请求的资源未修改，当协商缓存命中时会返回这个状态码。
- 4xx
    - **400 Bad Request**，客户端请求的语法错误，服务器无法理解
    - **401 Unauthorized**，请求要求用户的身份认证
    - **403 Forbidden**，服务器禁止访问，比如法律禁止、信息敏感。
    - **404 Not Found**，没在服务器上找到相应的资源。
    - **405 Method Not Allowed**，请求方法不被服务器端允许。
    - **406 Not Acceptable**，资源无法满足客户端的条件。
    - **408 Request Timeout**，服务器等待了太长时间。
    - **409 Conflict**，多个请求发生了冲突。
    - **413 Request Entity Too Large**，请求体的数据过大。
    - **414 Request-URI Too Long**，请求行里的 URI 太大。
    - **429 Too Many Request**，客户端发送的请求过多。
    - **431 Request Header Fields Too Large**，请求头的字段内容太大。
- 5xx
    - **500 Internal Server Error**，服务器出错了，无法完成请求
    - **501 Not Implemented**，表示客户端请求的功能服务器还不支持。
    - **502 Bad Gateway**，服务器自身是正常的，但访问的时候出错了，
    - **503 Service Unavailable**，表示服务器当前很忙，暂时无法响应服务。


### Accept系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。

### 对于定长和不定长的数据，HTTP 是怎么传输的？
- 定长包体
    - 带上 Content-Length, 来指明包体的长度。
- 不定长包体
    - 设置 Transfer-Encoding: chunked

### HTTP 中如何处理表单数据的提交？
- 两种不同的Content-Type取值
    1. application/x-www-form-urlencoded
    2. multipart/form-data

### HTTP1.1 如何解决 HTTP 的队头阻塞问题？
- 并发连接
- 域名分片，分出非常多的二级域名，而它们都指向同样的一台服务器

### 如何理解 HTTP 缓存及缓存代理？

1. 首先通过 Cache-Control 验证强缓存是否可用，可以用直接用
2. 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新
    - 更新返回资源、200
    - 否则，返回304，告诉浏览器直接从缓存获取资源

- 让代理服务器**接管一部分的服务端HTTP缓存**，客户端缓存过期后就近到代理缓存中获取，**代理缓存过期了才请求源服务器**，这样流量巨大的时候能明显降低源服务器的压力。

### 什么是跨域？浏览器如何拦截响应？如何解决？

- 同源政策(scheme(协议)、host(主机)和port(端口)都相同则为同源)

- 当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为**跨域请求**。

- 解决方法
    1. CORS，**跨域资源共享**，
    2. JSONP，虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。
    3. Nginx，高性能的反向代理服务器